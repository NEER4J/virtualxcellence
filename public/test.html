<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Reflective Cube</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #ffffff;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            color: #333;
            background: rgba(255, 255, 255, 0.8);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 0, 0, 0.1);
        }
        
        .control-group {
            margin-bottom: 10px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
        }
        
        input[type="range"] {
            width: 150px;
        }
        
        .info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #333;
            background: rgba(255, 255, 255, 0.8);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            font-size: 12px;
            border: 1px solid rgba(0, 0, 0, 0.1);
        }
        
        .reflection-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            font-weight: bold;
            color: #333;
            text-align: center;
            z-index: 1;
            pointer-events: none;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .reflection-text h1 {
            margin: 0;
            font-size: 64px;
            background: linear-gradient(45deg, #333, #666);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .reflection-text p {
            margin: 10px 0 0 0;
            font-size: 24px;
            opacity: 0.7;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="canvas-container"></div>
        
        <div class="reflection-text">
            <h1>REFLECTIVE</h1>
            <p>3D CUBE</p>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <label for="rotationSpeed">Rotation Speed</label>
                <input type="range" id="rotationSpeed" min="0" max="0.02" step="0.001" value="0.01">
            </div>
            <div class="control-group">
                <label for="reflectionStrength">Reflection Strength</label>
                <input type="range" id="reflectionStrength" min="0" max="2" step="0.1" value="1">
            </div>
            <div class="control-group">
                <label for="backgroundMorph">Background Morph</label>
                <input type="range" id="backgroundMorph" min="0" max="1" step="0.1" value="0.5">
            </div>
        </div>
        
        <div class="info">
        <p>Drag to rotate â€¢ Scroll to zoom</p>
            <p>Use controls to adjust the cube properties</p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <script>
        class ReflectiveCube {
            constructor() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.controls = null;
                this.cube = null;
                this.backgroundPlane = null;
                this.rotationSpeed = 0.01;
                this.reflectionStrength = 1;
                this.backgroundMorph = 0.5;
                
                this.init();
                this.createCube();
                this.createBackground();
                this.setupControls();
                this.animate();
                this.setupEventListeners();
            }
            
            init() {
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x000000, 0);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.renderer.outputEncoding = THREE.sRGBEncoding;
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 1;
                
                document.getElementById('canvas-container').appendChild(this.renderer.domElement);
                
                this.camera.position.z = 5;
                
                // Add orbit controls
                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                this.controls.enableZoom = true;
            }
            
            createCube() {
                const geometry = this.createRoundedBoxGeometry(2, 2, 2, 0.2, 8);
                
                // Create a reflective material
                const material = new THREE.MeshPhysicalMaterial({
                    color: 0xffffff,
                    metalness: 0.1,
                    roughness: 0.1,
                    reflectivity: 1.0,
                    clearcoat: 1.0,
                    clearcoatRoughness: 0.1,
                    transmission: 0.9,
                    transparent: true,
                    opacity: 0.8,
                    envMapIntensity: 1.0
                });
                
                this.cube = new THREE.Mesh(geometry, material);
                this.cube.castShadow = true;
                this.cube.receiveShadow = true;
                this.scene.add(this.cube);
                
                // Add some lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                this.scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 5, 5);
            directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                this.scene.add(directionalLight);
                
                // Add point lights for more dynamic lighting
                const pointLight1 = new THREE.PointLight(0xff6b6b, 0.5, 100);
                pointLight1.position.set(-5, 3, 5);
                this.scene.add(pointLight1);
                
                const pointLight2 = new THREE.PointLight(0x4ecdc4, 0.5, 100);
                pointLight2.position.set(5, -3, -5);
                this.scene.add(pointLight2);
            }
            
            createRoundedBoxGeometry(width, height, depth, radius, segments) {
                const geometry = new THREE.BufferGeometry();
                const vertices = [];
                const normals = [];
                const uvs = [];
                const indices = [];
                
                const w = width / 2;
                const h = height / 2;
                const d = depth / 2;
                const r = radius;
                const s = segments;
                
                // Create vertices for rounded box
                for (let x = 0; x <= s; x++) {
                    for (let y = 0; y <= s; y++) {
                        for (let z = 0; z <= s; z++) {
                            const px = (x / s) * width - w;
                            const py = (y / s) * height - h;
                            const pz = (z / s) * depth - d;
                            
                            // Apply rounding
                            const nx = Math.abs(px) > w - r ? (px > 0 ? 1 : -1) : 0;
                            const ny = Math.abs(py) > h - r ? (py > 0 ? 1 : -1) : 0;
                            const nz = Math.abs(pz) > d - r ? (pz > 0 ? 1 : -1) : 0;
                            
                            const roundedX = nx !== 0 ? (px > 0 ? w - r : -w + r) + nx * r : px;
                            const roundedY = ny !== 0 ? (py > 0 ? h - r : -h + r) + ny * r : py;
                            const roundedZ = nz !== 0 ? (pz > 0 ? d - r : -d + r) + nz * r : pz;
                            
                            vertices.push(roundedX, roundedY, roundedZ);
                            
                            // Calculate normal
                            const normal = new THREE.Vector3(roundedX, roundedY, roundedZ).normalize();
                            normals.push(normal.x, normal.y, normal.z);
                            
                            // UV coordinates
                            uvs.push(x / s, y / s);
                        }
                    }
                }
                
                // Create faces
                for (let x = 0; x < s; x++) {
                    for (let y = 0; y < s; y++) {
                        for (let z = 0; z < s; z++) {
                            const a = x * (s + 1) * (s + 1) + y * (s + 1) + z;
                            const b = a + 1;
                            const c = a + (s + 1);
                            const d = c + 1;
                            
                            // Add two triangles for each face
                            indices.push(a, b, c);
                            indices.push(b, d, c);
                        }
                    }
                }
                
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
                geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
                geometry.setIndex(indices);
                
                return geometry;
            }
            
            createBackground() {
                // Set scene background to white
                this.scene.background = new THREE.Color(0xffffff);
            }
            
            setupControls() {
                const rotationSpeedSlider = document.getElementById('rotationSpeed');
                const reflectionStrengthSlider = document.getElementById('reflectionStrength');
                const backgroundMorphSlider = document.getElementById('backgroundMorph');
                
                rotationSpeedSlider.addEventListener('input', (e) => {
                    this.rotationSpeed = parseFloat(e.target.value);
                });
                
                reflectionStrengthSlider.addEventListener('input', (e) => {
                    this.reflectionStrength = parseFloat(e.target.value);
                    if (this.cube && this.cube.material) {
                        this.cube.material.envMapIntensity = this.reflectionStrength;
                    }
                });
                
                backgroundMorphSlider.addEventListener('input', (e) => {
                    this.backgroundMorph = parseFloat(e.target.value);
                });
            }
            
            setupEventListeners() {
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                // Rotate the cube
                if (this.cube) {
                    this.cube.rotation.x += this.rotationSpeed;
                    this.cube.rotation.y += this.rotationSpeed * 0.7;
                    this.cube.rotation.z += this.rotationSpeed * 0.3;
                }
                
                // Morph the text and background based on cube rotation
                this.morphElements();
                
                this.controls.update();
                this.renderer.render(this.scene, this.camera);
            }
            
            morphElements() {
                if (!this.cube) return;
                
                const time = Date.now() * 0.001;
                const rotationX = this.cube.rotation.x;
                const rotationY = this.cube.rotation.y;
                const rotationZ = this.cube.rotation.z;
                
                // Morph the text based on cube rotation
                const textElement = document.querySelector('.reflection-text');
                if (textElement) {
                    const morphFactor = this.backgroundMorph;
                    const wave1 = Math.sin(rotationX * 2 + time) * morphFactor;
                    const wave2 = Math.cos(rotationY * 2 + time * 0.7) * morphFactor;
                    
                    // Transform the text
                    const scale = 1 + Math.abs(wave1) * 0.1;
                    const skewX = wave2 * 2;
                    const skewY = wave1 * 1;
                    
                    textElement.style.transform = `translate(-50%, -50%) scale(${scale}) skew(${skewX}deg, ${skewY}deg)`;
                    
                    // Change text color based on rotation
                    const hue = (rotationX + rotationY) * 0.1 + time * 0.1;
                    const saturation = 0.3 + Math.abs(wave1) * 0.2;
                    const lightness = 0.2 + Math.abs(wave2) * 0.1;
                    
                    const color = `hsl(${(hue * 360) % 360}, ${saturation * 100}%, ${lightness * 100}%)`;
                    textElement.style.color = color;
                }
                
                // Morph the background color
                const body = document.body;
                if (body) {
                    const morphFactor = this.backgroundMorph;
                    const wave1 = Math.sin(rotationX * 1.5 + time * 0.5) * morphFactor;
                    const wave2 = Math.cos(rotationY * 1.5 + time * 0.3) * morphFactor;
                    
                    // Create subtle background color changes
                    const baseHue = (rotationX + rotationY) * 0.05 + time * 0.02;
                    const saturation = 0.05 + Math.abs(wave1) * 0.02;
                    const lightness = 0.98 + Math.abs(wave2) * 0.02;
                    
                    const bgColor = `hsl(${(baseHue * 360) % 360}, ${saturation * 100}%, ${lightness * 100}%)`;
                    body.style.background = bgColor;
                }
            }
        }
        
        // Initialize the application
        new ReflectiveCube();
    </script>
</body>
</html>
